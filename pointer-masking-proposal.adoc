[[risc-v-pointer-masking-proposal]]

# RISC-V Pointer Masking proposal

RISC-V ISA Specification. Working draft, subject to change.

_Adam Zabrocki_, _Lee Campbell_, _Martin Maas_, _RISC-V TEE_ and _J Extension Task Groups_

**Contributors: ** Jecel Assumpcao, Allen Baum, Paul Donahue, Greg Favor, Andy Glew, John Ingalls, Christos Kotselidis, Ian Rogers, Josh Scheid, Kostya Serebryany, Boris Shingarov, Foivos Zakkak, Members of the TEE and J Extension Task Groups

[[introduction]]
## Introduction

RISC-V Pointer Masking (PM) is a feature which provides a possibility of implementing “memory tagging” by ignoring various bits (defined by mask) of the [.underline]#_effective address_# (virtual or physical) on RV128, RV64 and RV32.

[.underline]#_Effective address_# is an address generated by the address generation logic before it is sent to the memory subsystem. As such, there is no special handling of physical vs. virtual memory at the software level.

Memory tagging (MT) is a technique which can significantly improve the memory safety state of any application (including code running in more privileged modes). MT can be fully implemented in the hardware or partially hardware assisted. However, both implementations require a PM feature to be enabled to not overwhelm the performance.

General idea of MT is based on assigning a tag to every granule of memory (a small, e.g. 16-byte, naturally aligned memory region). All accesses to memory must be made via a pointer with the correct tag. Use of an incorrect tag is noted and the monitor software can choose what to do with such a situation (e.g. could be killing the process, or just report it to the user immediately). To be able to store the tag in every memory pointer (poisoning the pointer) and correctly using it in running applications without significant performance impact, PM is necessary.

This document proposes an extension for RISC-V called PM (Pointer Masking) which in the future might be enhanced for implementing a full hardware memory tagging.

[[proposal]]
## Proposal

We propose to add:

* new PM configuration CSR register called _**MMTE**_ (Memory Tagging Extension)
* new PM pointer masking CSR register for each privilege mode called _**MPMMASK**_ (Pointer Masking Mask)
* new PM pointer base CSR register for each privilege mode called _**MPMBASE**_ (Pointer Masking Base)

Restricted views of the _**mmte**_ register appear as the _**smte**_, _**vsmte**_ and _**umte**_ registers in the HS/S-mode, VS-mode and (V)U-mode ISAs respectively.

Each privilege mode has own copy of pointer masking CSR register. It appears as the _**mpmmask**_, _**spmmask**_, _**vspmmask**_ and _**upmmask**_ registers in the M-mode, HS/S-mode, VS-mode and (V)U-mode ISAs, respectively.

Each privilege mode has its own copy of pointer base CSR register. It appears as the _**mpmbase**_, _**spmbase**_, _**vspmbase**_ and _**upmbase**_ registers in the M-mode, HS/S-mode, VS-mode and (V)U-mode ISAs, respectively.

The purpose of the _**mpmmask**_ register is to be able to precisely define a mask whose bits of the effective address are ignored. The actual address can be calculated by using requested address and _**mpmmask**_ register.

Additionally, _**mpmbase**_ register can be defined, allowing to replace those bits of the actual_address which are defined to be masked by _**mpmmask**_. _**mpmbase**_ can be configured to replace only the subset of the masked bits, and the remaining are still ignored and can be used for any purpose (e.g. memory tagging).

If _**mpmbase**_ register is set (has value other than zero), actual address can be calculated by using requested address, _**mpmmask**_ and _**mpmbase**_ register:

[source]
.Equation 1.
----
actual_address = (requested_address & ~mpmmask) | mpmbase
----

_**mpmbase**_ register can be read-only and hardwired to 0. In such case, the actual address will be calculated only by using requested address and _**mpmmask**_ register.

When PM extension is enabled, _**mpmmask**_ and _**mpmbase**_ registers allow to implement in-process isolation feature. That feature allows for each thread to be isolated to a given block of the address space. It can be used to isolate untrusted code within a process. A high-level concept can be seen on Picture 1.

.Picture 1: In-Process isolation leveraging _**mpmmask**_ and _**mpmbase**_ registers
image:media/image1.png[image,width=451,height=394]

_**MMTE**_ layout can be found in Figure 1a, 1b, 1c and 1d for M, HS/S, VS and (V)U-mode. +

_**MPMMASK**_ layout can be found in Figure 2a, 2b, 2c and 2d for M, HS/S, VS and (V)U-mode. +

_**MPMBASE**_ layout can be found in Figure 3a, 3b, 3c and 3d for M, HS/S, VS and (V)U-mode. +

Table 1 explains the meaning of _PM_ bits for RV32, RV64 and RV128. +
Table 2 explains the meaning of _XS_ bits for RV32, RV64 and RV128. +

:table-caption!:

[%header, cols=5*]
.Figure 1a: Memory Tagging Extension register (_**mmte**_) M-mode
,===
mmte[XLEN-1:7],mmte[6:6],mmte[5:4],mmte[3:2],mmte[1:0]
WPRI,M-mode PM.Enabled,HS/S-mode PM,(V)U-mode PM,XS bits
,===

[%header, cols=4*]
.Figure 1b: Memory Tagging Extension register (_**smte**_) HS/S-mode
,===
smte[XLEN-1:6],smte[5:4],smte[3:2],smte[1:0]
WPRI,HS/S-mode PM,U-mode PM,XS bits
,===

[%header, cols=4*]
.Figure 1c: Memory Tagging Extension register (_**vsmte**_) for VS-mode
,===
vsmte[XLEN-1:6],vsmte[5:4],vsmte[3:2],vsmte[1:0]
WPRI,VS-mode PM,VU-mode PM,XS bits
,===

[%header, cols=3*]
.Figure 1d: Memory Tagging Extension register (_**umte**_) for (V)U-mode
,===
umte[XLEN-1:4],umte[3:2],umte[1:0]
WPRI,(V)U-mode PM,WPRI
,===

[cols="15%,15%,70%", options="header"]
.Table 1: Meaning of _PM_ bits for RV32, RV64 and RV128
|===========================================================================================================================
^|*PM Bits* ^|*Name* ^|*Meaning*
^.^| PM[0] ^.^| PM.Enabled |

  0 – PM is disabled (_default_) +
  1 – PM is enabled

^.^| PM[1] ^.^| PM.Current |

 0 – _**xPMMASK**_ and _**xPMBASE**_ registers can only be modified by the higher privilege mode +
 1 – _**xPMMASK**_ and _**xPMBASE**_ registers can be modified by the same privilege mode

|===========================================================================================================================

[cols="15%,70%", options="header"]
.Table 2: Meaning of _XS_ bits for RV32, RV64 and RV128
|===========================================================================================================================
^|*Status* ^|*Meaning*
^.^| 0 | PM extension is not used (cannot write to any PM CSRs)
^.^| 1 | PM CSRs are writeable but have the initial value (0)
^.^| 2 | Some registers may have non-initial values, but those were saved before (clean)
^.^| 3 | Some registers have unsaved values (dirty)
|===========================================================================================================================

[%header, cols=1*]
.Figure 2a: Memory Tagging Extension register (_**mpmmask**_) for M-mode
,===
mpmmask[XLEN-1:0]
MASK
,===

[%header, cols=1*]
.Figure 2b: Memory Tagging Extension register (_**spmmask**_) for HS/S-mode
,===
spmmask[XLEN-1:0]
MASK
,===

[%header, cols=1*]
.Figure 2c: Memory Tagging Extension register (_**vspmmask**_) for VS-mode
,===
vspmmask[XLEN-1:0]
MASK
,===

[%header, cols=1*]
.Figure 2d: Memory Tagging Extension register (_**upmmask**_) for (V)U-mode
,===
upmmask[XLEN-1:0]
MASK
,===

//-

[%header, cols=1*]
.Figure 3a: Memory Tagging Extension register (_**mpmbase**_) for M-mode
,===
mpmbase[XLEN-1:0]
BASE
,===

[%header, cols=1*]
.Figure 3b: Memory Tagging Extension register (_**spmbase**_) for HS/S-mode
,===
spmbase[XLEN-1:0]
BASE
,===

[%header, cols=1*]
.Figure 3c: Memory Tagging Extension register (_**vspmbase**_) for VS-mode
,===
vspmbase[XLEN-1:0]
BASE
,===

[%header, cols=1*]
.Figure 3d: Memory Tagging Extension register (_**upmbase**_) for (V)U-mode
,===
upmbase[XLEN-1:0]
BASE
,===


[[explanation]]
## Explanation

_**xMTE**_ register fulfills two-fold function:

1. Can only be programmable by more privileged mode (unless PM.Current bit is enabled) +
2. Performs status register function for the current privilege mode +

_XS_ bits from **_MMTE_** register are only accessible in M, S and VS-mode. _XS_ field encodes the status of Pointer Masking extension in U and VU-mode. These bits can be checked by a context switch routine to quickly determine whether a state save or restore is required. _XS_ field is automatically updated by the hardware when PM CSR registers are modified. Privileged code can directly modify _XS_ bits to restore previously saved _XS_ status (e.g. by the context restore routine).
_XS_ bits in M-mode are desired for implementation without S-mode for determining how to perform context switch in U-mode. Otherwise, _XS_ bits in M-mode might mirror _XS_ bits in (V)S-mode or can be hardwired to 0.
Additionally, any changes to the PM CSRs affect global _XS_ bits in the **mstatus** register.

_PM_ bits from **_MMTE_** register are accessible in all modes ((V)U/VS/HS/S/M) and can be read to query if the PM feature is currently enforced. By default, only higher privileged code can set the value for _PM_ bits. However, higher privileged code can enable _PM.Current_ bit for lower privileged code. In such scenario, current privilege code has a possibility to self-manage its own configuration of _PM_ bits.

By default, the current CPU mode is using _**xPMMASK**_, _**xPMBASE**_ and _PM_ bits corresponding to it. When CPU is switching the mode, corresponding pair of _**xPMMASK**_, _**xPMBASE**_ and _PM_ bits are used.
Special carefulness is necessary when VU and U mode are available. If virtualization extension is enabled, and hypervisor is not using _**xPMMASK**_ / _**xPMBASE**_ CSRs for its U-mode then context switches these registers when it context switches between VMs.
If a hypervisor is using _**xPMMASK**_ / _**xPMBASE**_ CSRs for its U-mode, then it switches in its own pair before dropping down to U-mode. Later, HS/S-mode context switches in the pair for the VM that it returns to.

If higher privileged code needs to use _**xPMMASK**_ and _**xPMBASE**_ from the lower privilege mode, there are two possible solutions: +
1. Emulate equation 1. purely in software using _**xPMMASK**_ and  _**xPMBASE**_ CSRs from the desired privilege mode. +
2. If PM.Current is enabled it is possible to save the state of the current _**xPMMASK**_ and _**xPMBASE**_ CSRs and temporarily replace them with the desired one. At the end, original values can be restored. +


_**MPMMASK**_ register fully two-fold function:

1.  Based on PM bits configuration, it can be programmable by the higher privilege mode or by the current privilege mode +
2.  Performs status register function for the current privilege mode +

_**MPMBASE**_ register fully two-fold function:

1.  Based on PM bits configuration, it can be programmable by the higher privilege mode or by the current privilege mode
2.  Performs status register function for the current privilege mode

Any write access would be ignored if performed to the current _**xPMMASK**_, _**xPMBASE**_ and **_MMTE_** CSR registers and PM.Current is disabled. +

PM extension allows various flavors of implementation. If PM is not desired in specific RISC-V mode, appropriate CSRs could be read-only and hardwired to 0.
